%\documentclass[paper,twocolumn,twoside]{geophysics}
\documentclass[manuscript,revised]{geophysics}
%\documentclass[manuscript]{geophysics}

% An example of defining macros
\newcommand{\rs}[1]{\mathstrut\mbox{\scriptsize\rm #1}}
\newcommand{\rr}[1]{\mbox{\rm #1}}

% Extra packages
\usepackage{amsmath}
\usepackage{bm}
\usepackage[pdftex,colorlinks=true]{hyperref}
\hypersetup{
	allcolors=black,
}
\usepackage{lipsum}
\usepackage[table]{xcolor}

\renewcommand{\figdir}{figures} % figure directory

\begin{document}

\title{Fast equivalent layer technique for gravity data processing with Block-Toeplitz Toeplitz-Block matrix systems}

\renewcommand{\thefootnote}{\fnsymbol{footnote}} 

\ms{GEO-XXXX} % manuscript number

%\address{
%\footnotemark[1]Observat\'{o}rio Nacional, \\
%Department of Geophysics, \\
%Rio de Janeiro, Brazil}
%\author{Diego Takahashi\footnotemark[1], Vanderlei C. Oliveira
%Jr.\footnotemark[1] and Val\'eria C. F. Barbosa\footnotemark[1]}

%\footer{vanderlei@on.br}
%\lefthead{Takahashi, Oliveria Jr. \& Barbosa}
%\righthead{Fast equivalent layer for BTTB systems}

\maketitle

\begin{abstract}

\lipsum[1]

%We have developed an efficient and very fast equivalent layer technique for gravity data processing by modifying an iterative method grounded on excess mass constraint that does not require the solution of linear systems. Taking advantage of the properties related to the symmetric Block-Toeplitz Toeplitz-block (BTTB) and Block-Circulant Circulant-Block (BCCB) matrices, that raises when regular grids of observation points and equivalent sources (point masses) are used to set up a fictitious equivalent layer, we have developed an algorithm which greatly 
%reduces the number of flops and memory RAM necessary to estimate of a 2D mass distribution over the equivalent layer. The algorithm is based on the structure of symmetric BTTB matrix, where all its elements consist of the elements of the first row, which in turn can be embedded into a symmetric BCCB matrix. Likewise, only the first row of the BCCB matrix is needed to reconstruct the full matrix completely. From the first column of BCCB matrix, its eigenvalues can be calculated using the fast Fourier transform, which can be used to readily compute the matrix-vector product. As a result, our method is efficient to process very large datasets using either fine- or mid-grid meshes. The larger the dataset, the faster and more efficient our method becomes compared to the available equivalent-layer techniques. Synthetic tests demonstrate the ability of our method to satisfactorily upward- and downward-continuing the gravity data. Test with real data from Caraj\'as, Brazil, shows its applicability to process very large dataset at low computational cost.

\end{abstract}

\section{Introduction}

\lipsum[1-5]

%The equivalent layer is a well-known technique for processing potential-field data in applied geophysics since 1960. It comes from potential theory as a mathematical solution of the Laplace's equation, in the region above the sources, by using the Dirichlet boundary condition \citep{kellogg1929}.
%This theory states that any potential-field data produced by an arbitrary 3D physical property distribution can be exactly reproduced by a fictitious layer located at any depth and having a continuous 2D physical property  distribution. In practical situations, the layer is approximated by a finite set of sources (e.g., point masses or dipoles) and their physical properties are estimated by solving a linear system of equations that yield an acceptable potential-field data fit. These fictitious sources are called equivalent sources.
%
%Many previous works have used the equivalent layer as a processing technique of potential-field data. \citet{dampney1969} used the equivalent-layer technique for gridding and for computing the upward continuation of the potential-field data. \citet{cordell1992} and \citet{mendonca-silva1994} used it for interpolating and gridding potential-field data. \citet{emilia1973}, \citet{hansen-miyazaki1984} and \citet{li-oldenburg2010} used it for upward continuation of the potential-field data. \citet{silva1986}, \citet{leao-silva1989}, \citet{guspi-novara2009}, and \citet{oliveirajr-etal2013} used it for reducing the magnetic data to the pole. \citet{boggs-dransfield2004} used it for combining multiple data sets and Barnes and Lumley (2011) for gradient-data processing.
%
%The classic equivalent layer formulation consists in estimating the physical-property distribution within a layer, composed by a set of equivalent sources, by solving a linear system of equations formed by harmonic functions (e.g.,the inverse of the distance between the observation point and the equivalent source). When these observation points and equivalent sources are regularly spaced, a Toeplitz system arises. Toeplitz systems are well-known in many branches of science as in (1) mathematics, for solving partial and ordinary diferential equations \citep[e.g.,][]{lin-etal2003}; (2) image processing \citep[e.g.,][]{chan-etal1999} and; (3) computational neuroscience \citep[e.g.,][]{wray-green1994}. \citep{jin2003} and \citep{chan-jin2007} give many examples of applications for Toeplitz systems.
%
%In potential-field methods, the properties of Toeplitz system were used for downward continuation \citep{zhang-etal2016} and for 3D gravity-data inversion using a 2D multilayer model \citep{zhang-wong2015}. In the particular case of gravity data, the kernel generates a linear system with a matrix known as symmetric Block-Toeplitz Toeplitz-Block (BTTB).
%
%A wide variety of applications in mathematics and engineers that fall into Toeplitz systems propelled the development of a large variety of  methods for solving them. Direct methods were conceived by \citep{levinson1946} and by \citep{trench1964}. Currently the conjugate gradient is used in most cases. In \citet{grenander-szego1984}, Szeg{\"o} noticed that a circulant matrix can be diagonalized by taking the fast Fourier trasform of its first column, making it possible to calculate the matrix-vector product and solve the system with low computational cost \citep{strang-aarikka1986, olkin1986}. \citet{chan-jin2007} show some preconditioners to embedd the Toeplitz and BTTB matrices into, respectively, circulant matrices and Block-Circulant Circulant-Block (BCCB) by solving the system applying the conjugate gradient method.
%
%Although the use of the equivalent-layer technique increased over the last decades, one of the biggest problem is still its high computational cost for processing large-data sets. \citet{siqueira-etal2017} developed a computationally efficient scheme for processing gravity data. This scheme does not solve a linear system, instead uses an iterative process that corrects the physical-property distribution over the equivalent layer by adding mass corrections that are proportional to the gravity residual. Although efficient, the method presented by \citet{siqueira-etal2017} requires, at each iteration,  the full computation of the forward problem to guarantee the convergence of the algorithm. The time spent on forward modeling accounts for most of the total computation time of their method.
%
%We propose the use of BTTB and BCCB matrices properties to efficiently  solve the forward modeling in method of \citet{siqueira-etal2017}, resulting in faster parameter estimation and the possibility to use very large datasets. Here, we show how the system memory (RAM) usage can be drastically decreased by calculating only the first row of the BTTB matrix and embedding into a BCCB matrix. Using the Szeg\"{o} theorema  combined with \cite{strang-aarikka1986}, the matrix-vector product can be accomplished with very low cost, reducing in some orders of magnitude the number of operations required to complete the process. We present synthetic tests to validate our proposal and real field data from Caraj\'as, Brazil to demonstrate its applicability.


\section*{Methodology}

\subsection{Equivalent layer technique for gravity data processing}

Let $d^{o}_{i}$ be the observed gravity data at
the point $(x_{i}, y_{i}, z_{i})$, $i = 1, ..., N$, of a local Cartesian
system with $x$ axis pointing to North, the $y$ axis pointing to East and 
the $z$ axis pointing downward.
We consider that the gravity data are properly processed so that they
represent the difference between the observed gravity
(corrected from non-gravitational effects due to the vehicle motion) 
and the normal gravity, at the same point. This quantity is called
\textit{gravity disturbance} \citep{hofmann-wellenhof-moritz2005}. 
Several authors have discussed the differences between the gravity 
anomaly and the gravity disturbance, as well as proposed that the second 
is more appropriated for geophysical applications. A detailed discussion
about this theoretical topic is beyond the scope of our work and we
refer the reader to \citet{li-gotze2001, fairhead-etal2003, 
hackney-featherstone2003, hinze-etal2005} and 
\citet{vajda-etal2006, vajda-etal2007, vajda-etal2008}, for example.

In a local coordinate system, the gravity disturbance can be considered 
as the $z$~-~component (or vertical component) of the gravitational 
attraction exerted by gravity sources. As a consequence, it can be
approximated by a linear combination of ...

\begin{equation}
\delta g(x_{i}, y_{i}, z_{i}) = \sum_{j=1}^{N} p_j a_{ij} \: ,
\label{eq:predicted-data-i}
\end{equation}

\begin{equation}
a_{ij}= \frac{G \, (z_{0} - z_{i}) \, 10^{-5}}{\left[(x_{i} - x_{j})^{2} +
(y_{i} - y_{j})^{2} +	(z_{i} - z_{0})^{2} \right]^{\frac{3}{2}}} \; .
\label{eq:aij}
\end{equation}

\begin{equation}
\mathbf{d}(\mathbf{p}) = \mathbf{A} \mathbf{p} \: ,
\label{eq:predicted-data-vector}
\end{equation}

The elements $a_{ij}$ (equation \ref{eq:aij}) forming the matrix 
$\mathbf{A}$ (equation \ref{eq:predicted-data-vector}) are defined in terms of the 
coordinates $x_{i}$, $y_{i}$, $x_{j}$ and $y_{j}$, which are associated with the
observed data and the equivalent sources.
Based on this, we designate these coordinates as \textit{matrix coordinates} and the 
indices $i$ and $j$ as \textit{matrix indices}.

\begin{equation}
\Psi(\mathbf{p}) = \| \mathbf{d}^{o} - \mathbf{d(p)} \|_{2}^{2} + 
\mu \, \| \mathbf{p} \|_{2}^{2} \: ,
\label{eq:goal-function}
\end{equation}

\begin{equation}
\hat{\mathbf{p}} = \left( \mathbf{A}^{\top}\mathbf{A} + 
\mu \, \mathbf{I} \right)^{-1}
\mathbf{A}^{\top} \mathbf{d}^{o} \: .
\label{eq:estimated-p-parameter-space}
\end{equation}


\subsection{Structure of matrix $\mathbf{A}$ for regular grids}

Consider that the observed data are located on an $N_{x} \times N_{y}$ regular grid of
points regularly spaced from $\Delta x$ and $\Delta y$ along the $x$ and $y$ directions,
respectively, on a horizontal plane defined by the constant vertical coordinate $z_{1} < z_{0}$. 
As a consequence, a given pair of matrix coordinates $(x_{i}, y_{i})$, defined by the matrix index 
$i$, $i = 1, \dots, N = N_{x} N_{y}$, is equivalent to a pair of coordinates $(x_{k}, y_{l})$
given by:
\begin{equation}
x_{i} \equiv x_{k} = x_{1} + \left[ k(i) - 1 \right] \, \Delta x \: , 
\label{eq:xi}
\end{equation}
and
\begin{equation}
y_{i} \equiv y_{l} = y_{1} + \left[ l(i) - 1 \right] \, \Delta y \: ,
\label{eq:yi}
\end{equation}
where $k(i)$ and $l(i)$ are integer functions of the matrix index $i$.
These equations can also be used to define the horizontal coordinates 
$x_{j}$ and $y_{j}$ associated with the $j$-th equivalent source,
$j = 1, \dots, N = N_{x}N_{y}$. In this case, the integer functions
$k(j)$ and $l(j)$ are evaluated by using the index $j$ instead of $i$.
For convenience, we designate $x_{k}$ and $y_{l}$ as \textit{grid coordinates}
and the indices $k$ and $l$, defined by the integer functions, as
\textit{grid indices}.

The integer functions assume different forms depending on the 
orientation of the regular grid of data.
Consider the case in which the grid is oriented along the
$x$-axis (Figure 1a). For convenience, we designate these grids as 
$x$-\textit{oriented grids}. For them, we have the following integer functions:
\begin{equation}
i(k, l) = (l - 1) \, N_{x} + k \quad ,
\label{eq:i-x-oriented}
\end{equation}
\begin{equation}
l(i) = \Bigg\lceil \frac{i}{N_{x}} \Bigg\rceil
\label{eq:l-x-oriented}
\end{equation}
and
\begin{equation}
k(i)  = i - \Bigg\lceil \frac{i}{N_{x}} \Bigg\rceil N_{x} + N_{x} \quad ,
\label{eq:k-x-oriented}
\end{equation}
where $\lceil \cdot \rceil$ denotes the ceiling function \citep[][ p. 67]{graham-etal1994}.
Notice that these integer functions are defined in terms of the matrix index $i$, but they can 
be defined in the same way by using the index $j$ instead of $i$.
Figure 1a illustrates an $x$-oriented grid defined by $N_{x} = 4$ and $N_{y} = 3$.
In this example, the matrix coordinates $x_{7}$ and $y_{7}$, defined by the matrix index $i = 7$ (or $j = 7$), 
are equivalent to the grid coordinates $x_{3}$ and $y_{2}$, which are defined by the grid indices
$k = 3$ and $l = 2$, respectively. These indices are computed with equations \ref{eq:l-x-oriented}
and \ref{eq:k-x-oriented}, by using the matrix index $i = 7$ (or $j = 7$).

Now, consider the case in which the regular grid of data is oriented along 
the $y$-axis (Figure 1b). For convenience, we call them $y$-\textit{oriented grids}.
Similarly to $x$-oriented grids, we have the following integer functions associated with
the $y$-oriented grids:
\begin{equation}
i(k, l) = (k - 1) \, N_{y} + l \quad ,
\label{eq:i-y-oriented}
\end{equation}
\begin{equation}
k(i) = \Bigg\lceil \frac{i}{N_{y}} \Bigg\rceil
\label{eq:k-y-oriented}
\end{equation}
and
\begin{equation}
l(i) = i - \Bigg\lceil \frac{i}{N_{y}} \Bigg\rceil N_{y} + N_{y} \quad .
\label{eq:l-y-oriented}
\end{equation}
Figure 1b illustrates an $y$-oriented grid defined by $N_{x} = 4$ and $N_{y} = 3$.
In this example, the matrix coordinates $x_{7}$ and $y_{7}$, defined by the matrix index 
$i = 7$ (or $j = 7$), are equivalent to the grid coordinates $x_{3}$ and $y_{1}$, which are 
defined by the grid indices $k = 3$ and $l = 1$, respectively. Differently from the example
of $x$-oriented grid shown in Figure 1a, the grid indices of the present example are 
computed with equations \ref{eq:l-y-oriented} and \ref{eq:k-y-oriented}, by using the 
matrix index $i = 7$ (or $j = 7$).

The elements $a_{ij}$ (equation \ref{eq:aij}) written in terms of the matrix coordinates 
$x_{i}$ (equation \ref{eq:xi}) and $y_{i}$ (equation \ref{eq:yi}) are given by:
\begin{equation}
a_{ij} = \frac{G \, \Delta z \, 10^{-5}}{ \left[ 
\left( \Delta k_{ij} \, \Delta x \right)^{2} + 
\left( \Delta l_{ij} \, \Delta y \right)^{2} + 
\left( \Delta z \right)^{2} \right]^{\frac{3}{2}}} \: ,
\label{eq:aij-regular-grids}
\end{equation}
where $\Delta z = z_{0} - z_{1}$, 
$\Delta k_{ij} = k(i) - k(j)$ (equations \ref{eq:k-x-oriented} and \ref{eq:k-y-oriented}) and
$\Delta l_{ij} = l(i) - l(j)$ (equations \ref{eq:l-x-oriented} and \ref{eq:l-y-oriented}).
The structure of matrix $\mathbf{A}$ (equation \ref{eq:predicted-data-vector}), for the case 
in which its elements are given by $a_{ij}$ (equation \ref{eq:aij-regular-grids}), is defined 
by the coefficients $\Delta k_{ij}$ and $\Delta l_{ij}$.

For $x$-oriented grids, the coefficients $\Delta k_{ij}$ and $\Delta l_{ij}$ are 
computed by using equations \ref{eq:k-x-oriented} and \ref{eq:l-x-oriented}, respectively.
In this case, the matrix $\mathbf{A}$ (equation \ref{eq:predicted-data-vector}) is a 
Block-Toeplitz Toeplitz-Block (BTTB) matrix \citep[][ p. 67]{chan-jin2007}
composed of $N_{y} \times N_{y}$ blocks, where each block is formed by 
$N_{x} \times N_{x}$ elements.
In this kind of matrix, blocks lying at the same diagonal are equal to each other
and they are themselves Toeplitz matrices.
We follow the common notation found in the literature and represent 
the blocks lying at the same diagonal as $\mathbf{A}_{m}$, where $m$ is an
index that we conveniently call \textit{block index}.
The block indices $m$ associated with the blocks $\mathbf{A}_{m}$ lying at, above 
and below the main diagonal of $\mathbf{A}$ assume the values $m = 0$, $m > 0$ and $m < 0$,
respectively.
Those above the main diagonal have $m$ varying from $1$, close to the main diagonal, 
to $N_{y} - 1$, at the upper right corner of $\mathbf{A}$.
On the other hand, those below the main diagonal have $m$ 
varying from $-1$, close to the main diagonal, 
to $-N_{y} + 1$, at the bottom left corner of $\mathbf{A}$.
For $y$-oriented grids, the coefficients $\Delta k_{ij}$ and $\Delta l_{ij}$ are 
computed by using equations \ref{eq:k-y-oriented} and \ref{eq:l-y-oriented}, respectively.
In this case, $\mathbf{A}$ (equation \ref{eq:predicted-data-vector}) is a 
BTTB matrix composed of $N_{x} \times N_{x}$ blocks, where each block is formed by 
$N_{y} \times N_{y}$ elements.
The block index $m$ associated with $y$-oriented grids vary from $-N_{x} + 1$,
at the bottom left, to $N_{x} - 1$, at the upper right corner of $\mathbf{A}$.

Consider a given block $\mathbf{A}_{m}$ of the matrix $\mathbf{A}$
(equation \ref{eq:predicted-data-vector}) defined by elements $a_{ij}$ 
(equation \ref{eq:aij-regular-grids}) that are computed in an $x$-oriented grid. 
In this case, the coefficients $\Delta k_{ij}$ 
(equation \ref{eq:k-x-oriented}) associated with the elements $ij$ within 
$\mathbf{A}_{m}$ form a Skew-Symmetric Toeplitz matrix $\mathbf{\Delta K}_{m}$ 
\citep[][ p. 161]{golub-vanloan2013}. The first column of this matrix is formed 
by the integer elements $0, 1, \dots, N_{x} - 1$.
On the other hand, all the coefficients $\Delta l_{ij}$ (equation \ref{eq:l-x-oriented})
that define the elements $ij$ within $\mathbf{A}_{m}$ have the same value $-m$. 
As a consequence, they form a matrix $\mathbf{\Delta L}_{m} = -m \, \mathbf{1}$, 
where $\mathbf{1}$ is a matrix with all elements equal to $1$. 
This well-defined pattern of matrices 
$\mathbf{\Delta K}_{m}$ and $\mathbf{\Delta L}_{m}$ can be easily verified by computing
the coefficients $\Delta k_{ij}$ (equation \ref{eq:k-x-oriented}) and
$\Delta l_{ij}$ (equation \ref{eq:l-x-oriented}) for all matrix indices $i$ and $j$.
By using the $x$-oriented grid shown in Figure 1a, the matrices $\mathbf{\Delta K}_{m}$
and $\mathbf{\Delta L}_{m}$ defined by using, for example, the block index $m = 1$, are
given by:
\begin{equation}
\mathbf{\Delta K}_{1} = \begin{bmatrix}
0 & -1 & -2 & -3 \\
1 & 0 & -1 & -2 \\
2 & 1 & 0 & -1 \\
3 & 2 & 1 & 0
\end{bmatrix}
\label{eq:K1-x-oriented-example}
\end{equation}
and
\begin{equation}
\mathbf{\Delta L}_{1} = \begin{bmatrix}
-1 & -1 & -1 & -1 \\
-1 & -1 & -1 & -1 \\
-1 & -1 & -1 & -1 \\
-1 & -1 & -1 & -1
\end{bmatrix} \quad .
\label{eq:L1-x-oriented-example}
\end{equation}

Consider now a given block $\mathbf{A}_{m}$ of the matrix $\mathbf{A}$
(equation \ref{eq:predicted-data-vector}) defined by elements $a_{ij}$ 
(equation \ref{eq:aij-regular-grids}) that are computed in an $y$-oriented grid. 
In this case, the coefficients $\Delta k_{ij}$ 
(equation \ref{eq:k-y-oriented}) associated with the elements $ij$ within 
$\mathbf{A}_{m}$ form a matrix $\mathbf{\Delta K}_{m} = -m \, \mathbf{1}$.
On the other hand, the matrix $\mathbf{\Delta L}_{m}$ formed by the coefficients
$\Delta l_{ij}$ (equation \ref{eq:l-x-oriented}) that define the elements $ij$ 
within $\mathbf{A}_{m}$ is a Skew-Symmetric Toeplitz matrix.
The first column of this matrix is formed 
by the integer elements $0, 1, \dots, N_{y} - 1$.
This well-defined pattern of matrices 
$\mathbf{\Delta K}_{m}$ and $\mathbf{\Delta L}_{m}$ can also be verified by computing
the coefficients $\Delta k_{ij}$ (equation \ref{eq:k-y-oriented}) and
$\Delta l_{ij}$ (equation \ref{eq:l-y-oriented}) for all matrix indices $i$ and $j$.
To illustrate these matrices, we compute them by using the $y$-oriented grid shown in Figure 1b
and a block index $m = 1$. The results are given by:
\begin{equation}
\mathbf{\Delta K}_{1} = \begin{bmatrix}
-1 & -1 & -1 \\
-1 & -1 & -1 \\
-1 & -1 & -1 
\end{bmatrix}
\label{eq:K1-y-oriented-example}
\end{equation}
and
\begin{equation}
\mathbf{\Delta L}_{1} = \begin{bmatrix}
0 & -1 & -2 \\
1 & 0 & -1 \\
2 & 1 & 0
\end{bmatrix} \quad .
\label{eq:L1-y-oriented-example}
\end{equation}

From these examples (equations \ref{eq:K1-x-oriented-example}, \ref{eq:L1-x-oriented-example}, 
\ref{eq:K1-y-oriented-example} and \ref{eq:L1-y-oriented-example}), we conclude that,
in both cases ($x$- and $y$-oriented grids),
the blocks $\mathbf{A}_{m}$ above the main diagonal (with block index $m > 0$) are equal to those
below the main diagonal (with block index $m < 0$), i. e., 
$\mathbf{A}_{m} = \mathbf{A}_{-m}$. Besides, we can see that each block $\mathbf{A}_{m}$ is
a symmetric Toeplitz matrix. These symmetries come from the fact that the coefficients
$\Delta k_{ij}$ (equations \ref{eq:k-x-oriented} and \ref{eq:k-y-oriented}) and
$\Delta l_{ij}$ (equations \ref{eq:l-x-oriented} and \ref{eq:l-y-oriented}) are
squared at the denominator of $a_{ij}$ (equation \ref{eq:aij-regular-grids}).

%\subsection{BCCB matrix-vector product}
%
%As previous discussed in the  fast equivalent layer technique section, the matrix-vector product accounts for most of the computational cost. When large data sets are used, this operation can take some time and even be prohibited by memory RAM shortage. In order to lessen this problem we transform the BTTB matrix $\mathbf{A}$ into a Block-Circulating Circulating-Block (BCCB) matrix $\mathbf{C}$ and use its eigenvalues to carry the product of $\mathbf{A}$ and an arbitrary vector $\mathbf{p}$. This strategy has been successfully applied by Zhang and Wong (2015) and Zhang et al. (2016) for optimizing the computational cost of 3D gravity inversion and downward continuation of potential field, respectively. Here, we use this strategy for improving the computational efficiency of the fast equivalent layer method proposed by \citet{siqueira-etal2017}.
%
%Following the example of our BTTB matrix $\mathbf{A}$ (equation \ref{eq:toeplitz_block_T}), its transformation into a BCCB matrix $\mathbf{C}$ is given by:
%
%\begin{equation}
%\tensor{C} =
%\pmatrix{
%	\tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} \cr
%	\tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} \cr
%	\tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} \cr
%	\tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} \cr
%	\tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} \cr
%	\tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} & \tensor{C_{2}} \cr
%	\tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}} & \tensor{C_{1}} \cr
%	\tensor{C_{1}} & \tensor{C_{2}} & \tensor{C_{3}} & \tensor{0} & \tensor{C_{3}} & \tensor{C_{2}} & \tensor{C_{1}} & \tensor{C_{0}}
%},
%\label{eq:circulant_elements}
%\end{equation}
%where each block $\mathbf{C}_{l}$ is:
%
%\begin{equation}
%\tensor{C}_{l} =
%\pmatrix{
%	\tensor{A}_{l} & \times \cr
%	\times & \tensor{A}_{l}
%} =
%\pmatrix{
%	a_{0}^{\ell} & a_{1}^{\ell} & a_{2}^{\ell} & 0^{\ell} & a_{2}^{\ell} & a_{1}^{\ell} \cr
%	a_{1}^{\ell} & a_{0}^{\ell} & a_{1}^{\ell} & a_{2}^{\ell} & 0^{\ell} & a_{2}^{\ell} \cr
%	a_{2}^{\ell} & a_{1}^{\ell} & a_{0}^{\ell} & a_{1}^{\ell} & a_{2}^{\ell} & 0^{\ell} \cr
%	0^{\ell} & a_{2}^{\ell} & a_{1}^{\ell} & a_{0}^{\ell} & a_{1}^{\ell} & a_{2}^{\ell} \cr
%	a_{2}^{\ell} & 0^{\ell} & a_{2}^{\ell} & a_{0}^{\ell} & a_{0}^{\ell} & a_{1}^{\ell} \cr
%	a_{1}^{\ell} & a_{2}^{\ell} & 0^{\ell} & a_{2}^{\ell} & a_{1}^{\ell} & a_{0}^{\ell}
%}.
%\label{eq:toeplitz_circulant_element}
%\end{equation}
%
%The matrix $\mathbf{C}$ is a $4N_x N_y \times 4N_x N_y$ Block-Circulant matrix formed by Circulant-Blocks matrices. This matrix is formed by a grid of $2N_x \times 2N_x$ blocks, where each block is a $2N_y \times 2N_y$ matrix.
%
%Instead of calculating the product $\mathbf{d} = \mathbf{A} \mathbf{p}$ (equation \ref{eq:predicted-data-vector}), we now carry the following multiplication:
%
%\begin{equation}
%\mathbf{C} \mathbf{v} = \mathbf{q} \: ,
%\label{eq:BCCB_vector_product}
%\end{equation}
%where $\mathbf{v}$ and $\mathbf{q}$ are $4N_x N_y \times 1$ vectors given, respectively, by:
%
%\begin{equation}
%\mathbf{v} =
%\pmatrix{
%	\mathbf{v}_{0} \cr
%	\mathbf{v}_{1} \cr
%	\vdots \cr
%	\mathbf{v}_{N_x- 1} \cr
%	\mathbf{0}_{(2 N_x N_y)}
%}
%\end{equation}
%
%\noindent and
%
%\begin{equation}
%\mathbf{q} =
%\pmatrix{
%	\mathbf{q}_{0} \cr
%	\mathbf{q}_{1} \cr
%	\vdots \cr
%	\mathbf{q}_{N_x - 1} \cr
%	\mathbf{\dagger}_{(2 N_x N_y)}
%} \: ,
%\end{equation}
%where $\mathbf{0}_{(2 N_x N_y)}$ is a $2 N_x N_y \times 1$ vector of zeros, $\mathbf{\dagger}_{(2 N_x N_y)}$ is $2 N_x N_y \times 1$ vector of ``garbage" (ACHAR UM JEITO MELHOR DE DESCREVER, CHAN E ZHANG DESCREVEM APENAS COMO ``A PARTE A SER JOGADA FORA") and $\mathbf{v}_{\ell}$ and $\mathbf{q}_{\ell}$, $\ell = 0, \dots, N_x-1$ are:
%
%\begin{equation}
%\mathbf{v}_{\ell} =
%\pmatrix{
%	\mathbf{p}_{\ell} \cr
%	\mathbf{0}_{(N_y)}
%}
%\end{equation}
%
%\noindent and
%
%\begin{equation}
%\mathbf{q}_{\ell} =
%\pmatrix{
%	\mathbf{d}_{\ell} \cr
%	\mathbf{\dagger}_{(N_y)}
%} \: ,
%\end{equation}
%where $\mathbf{0}_{(N_y)}$ is a $N_y \times 1$ vector of zeros, $\mathbf{\dagger}_{(N_y)}$ is a $N_y \times 1$ vector of ``garbage" (ACHAR UM JEITO MELHOR DE DESCREVER, CHAN E ZHANG DESCREVEM APENAS COMO ``A PARTE A SER JOGADA FORA")  and $\mathbf{d}_{\ell}$ and $\mathbf{p}_{\ell}$ are $N_y \times 1$ vectors partitioned from the original $\mathbf{d}$ and $\mathbf{p}$ vectors (equation \ref{eq:predicted-data-vector}).
%
%As demonstrated by \cite{grenander1984szeg}, circulant matrices can be diagonalized by taking the discrete Fourier transform (DFT), i.e., its eigenvalues can be easily calculated by a fast algorithm of DFT. For BCCB matrices \cite{chan2007introduction} demonstrate that they satisfy:
%
%\begin{equation}
%\mathbf{C} = \left(\mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right)^{\ast} \mathbf{\Lambda}\left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \: ,
%\label{eq:fft_BCCB}
%\end{equation}
%
%\noindent where $\mathbf{F}_{(2N_y)}$ and $\mathbf{F}_{(2N_x)}$ are the matrices of the discrete Fourier transform, ``$\otimes$'' represents the Kronecker product, ``$\ast$'' the conjugate matrix and $\mathbf{\Lambda}$ is the diagonal matrix $4N_xN_y \times 4N_xN_y$ containing the eigenvalues of $\mathbf{C}$. By proper manipulating equation \ref{eq:fft_BCCB} it is possible to calculate the eigenvalues of the BCCB matrix using only its first column:
%
%\begin{eqnarray}
%\left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \mathbf{C} = \mathbf{\Lambda} \, \left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \\
%\left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \, \mathbf{C} \, \mathbf{t}_{1} = \mathbf{\Lambda} \, \left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \, \mathbf{t}_{1} \\
%\left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \, \mathbf{c}_{0} = \mathbf{\Lambda} \, \frac{1}{\sqrt{4N_xN_y}}\mathbf{1}_{(4N_xN_y)} \\
%\left( \mathbf{F}_{(2N_y)} \otimes \mathbf{F}_{(2N_x)} \right) \, \mathbf{c}_{0} = \frac{1}{\sqrt{4N_xN_y}} \mathbf{\lambda} \quad ,
%\label{eq:fft_BCCB_column}
%\end{eqnarray}
%
%\noindent where $\mathbf{t}_{1}$ is a $4N_xN_y \times 1$ vector with first element equal to 1 and all the remaining elements equal to 0, the vector $\mathbf{c}_{0}$ $4N_xN_y \times 1$ is the first column of $\mathbf{C}$, $\mathbf{1}_{(4N_xN_y)}$ is a $4N_xN_y \times 1$ with all elements equal to 1 and $\mathbf{\lambda}$ is a vector representing the diagonal of $\mathbf{\Lambda}$ (the eigenvalues of $\mathbf{C}$). Note that using one of the Kronecker product properties equation \ref{eq:fft_BCCB_column} can be calculated using the 2D-DFT \cite[]{jain1989fundamentals}:
%
%\begin{eqnarray}
%\mathbf{F}_{(2N_x)} \mathbf{G} \, \mathbf{F}_{(2N_y)} &= \frac{1}{\sqrt{4N_xN_y}} \mathbf{L}
%\quad ,
%\label{eq:fft_BCCB_column_2D}
%\end{eqnarray}
%
%\noindent where $\mathbf{G}$ is a $2N_x \times 2N_y$ row-oriented matrix containing the elements of the first column $\mathbf{c}_{0}$ of $\mathbf{C}$ and $\mathbf{L}$ is a $2N_x \times 2N_y$ row-oriented matrix containing the eigenvalues $\mathbf{\lambda}$.
%
%By substituting equation \ref{eq:fft_BCCB} in equation \ref{eq:BCCB_vector_product}, using the fast calculation of the eigenvalues of BCCB matrices (equation \ref{eq:fft_BCCB_column_2D}) and using the same previous Kronecker product property, the auxiliary matrix-vetor product $\mathbf{C} \mathbf{v} = \mathbf{q}$ can be rewritten as follows:
%
%\begin{equation}
%\mathbf{F}_{(2 N_x)}^{\ast} \left[ \mathbf{L} \circ \left( \mathbf{F}_{(2N_x)} \mathbf{V} \, \mathbf{F}_{(2N_y)} \right) \right] \mathbf{F}_{(2N_y)}^{\ast} = \mathbf{Q} \: ,
%\label{eq:fft_q}
%\end{equation}
%
%\noindent where ``$\circ$'' denotes the Hadamard product, $\mathbf{L}$ is a $2N_x \times 2N_y$ row-oriented matrix containing the eigenvalues of $\mathbf{C}$, and $\mathbf{V}$ and $\mathbf{Q}$ are $2N_x \times 2N_y$ row-oriented matrices obtained from the vectors $\mathbf{v}$ and $\mathbf{q}$.
%
%Note that in general, the first column of blocks forming a BCCB matrix $\mathbf{C}_{\ell}$ (equation \ref{eq:circulant_elements}) is given by:
%
%\begin{equation}
%\left[\mathbf{C} \right]_{(0)} = 
%\pmatrix{
%\mathbf{C}_{0} \cr
%\mathbf{C}_{1} \cr
%\vdots \cr
%\mathbf{C}_{N_x-2} \cr
%\mathbf{C}_{N_x-1} \cr
%\mathbf{0} \cr
%\mathbf{C}_{N_x-1} \cr
%\mathbf{C}_{N_x-2} \cr
%\vdots \cr
%\mathbf{C}_{1}
%} \; ,
%\end{equation}
%where each block $\mathbf{C}_{\ell}$, $\ell = 0, \dots, N_x-1$, is a $2N_y \times 2N_y$ circulant matrix and $\mathbf{0}$ is a $2N_y \times 2N_y$ matrix with all elements equal to zero. Thus, the first column $\mathbf{c}_{0}$ of a circulant matrix $\mathbf{C}$ is given by:
%
%\begin{equation}
%\mathbf{c}_{0} =
%\pmatrix{
%	a_{00} \cr
%	a_{10} \cr
%	\vdots \cr
%	a_{(N_y-2)0} \cr
%	a_{N_y-1) 0} \cr
%	0 \cr
%	a_{N_y-1) 0} \cr
%	a_{(N_y-2)0} \cr
%	\vdots \cr
%	a_{10}
%} \:.
%\end{equation}
%
%To complete the process, after calculating the inverse to obtain $\mathbf{Q}$ it is necessary to rearrange its rows to obtain the vector $\mathbf{q}$ and also rearrange the elements of $\mathbf{q}$ to obtain the wanted vector $\mathbf{d(p)}$.

%The algorithm for computing the matrix-vector product $\mathbf{A}\mathbf{p}$ and obtaining the resulting vector $\mathbf{d(p)}$ can be summarized in the following steps:

%1. Compute the first column of the embedded $4N_x N_y \times 4N_x N_y$ BCCB matrix $\mathbf{C}$ by using the first column of the $N_x N_y \times N_x N_y$ BTTB matrix $\mathbf{A}$;

%2. Compute the eigenvalues of $\mathbf{C}$ rearranging them in rows of the $2N_x \times 2N_y$ matrix $\mathbf{L}$;

%3. Rearrange the vector $\mathbf{v}$ in the rows of the $2N_x \times 2N_y$ matrix $\mathbf{V}$;

%4. Compute the Hadammard product $\mathbf{L} \circ \tilde{\mathbf{P}}$, where $\tilde{\mathbf{P}} = \mathbf{F}_{(2N_x)} \mathbf{P} \, \mathbf{F}_{(2N_y)}$ is computed by using a fast algorithm for 2D DFT;

%5. Compute the resulting $2N_x \times 2N_y$ matrix $\mathbf{Q} = \mathbf{F}_{(2N_x)}^{\ast} \left[ \mathbf{L} \circ \tilde{\mathbf{P}}\right] \mathbf{F}_{(2N_y)}^{\ast}$ by using a fast algorithm for inverse 2D DFT;

%6. Rearrange the rows of $\mathbf{Q}$ to obtain the vector $\mathbf{q}$;

%7. Rearrange the elements of $\mathbf{q}$ to obtain the vector $\mathbf{d(p)}$.

\subsection{Computational performance}
In a normal procedure of the fast equivalent layer proposed by \citet{siqueira-etal2017}, at each iteration a full matrix $\tensor{A}$ (equation \ref{eq:predicted-data-vector}) is multiplied by the estimated mass distribution parameter vector $\hat{\mathbf{p}}^k$ producing the predicted gravity data $\mathbf{d(p)}$  iteratively . As pointed in \citet{siqueira-etal2017} the number of flops (floating-point operations) necessary to estimate the $N$-dimensional parameter vector inside the iteration loop is:

\begin{equation}
f_0 = N^{it} (3N + 2N^2) \; ,
\label{eq:float_classic}
\end{equation}

\noindent where $N^{it}$ is the number of iterations. From equation \ref{eq:float_classic} it is clear that the matrix-vector product ($2N^2$) accounts for most of the computational complexity in this method.

It is well known that FFT takes $N \log_2(N)$ flops \cite[]{brigham1988fast}. Computing the eigenvalues of the BCCB matrix ($4N \times 4N$) and applying 2D-FFT on the parameter vector (equation \ref{eq:fft_q}), takes $4N \log(4N)$ each. The point-multiplication takes $4N$. As it is necessary to compute the inverse FFT another two $4N \log(4N)$ must be taken in account. However, the sensibility matrix does not change during the process, thus, the eigenvalues of BCCB must be calculated only once, outside of the iteration. This lead us to a flops count in our method of:

\begin{equation}
f_1 = 4N\log(4N) + N^{it} (7N + 8N\log(4N)).
\label{eq:float_bccb}
\end{equation}

Another major improvement of this methodology is the exoneration of calculating the full sensibility matrix $\tensor{A}$ (equation \ref{eq:predicted-data-vector}). Each element needs $12$ flops (equation \ref{eq:aij}), totalizing $12N^2$ flops for the full matrix. Calculating only the first row of the BTTB matrix $12N$ flops is required.
Thus, the full flops count of the method presented by \citet{siqueira-etal2017}:

\begin{equation}
f_s = 12N^2 + N^{it} (3N + 2N^2),
\label{eq:float_siqueira}
\end{equation}

it is decreased in our method to:

\begin{equation}
f_f = 12N + 4N \log(4N) + N^{it} (7N + 8N\log(4N)).
\label{eq:float_new}
\end{equation}

Figure \ref{fig:float} shows the floating points to estimate the parameter vector using the fast equivalent layer with the method of \citet{siqueira-etal2017} (equation \ref{eq:float_classic}) and our approach (equation \ref{eq:float_bccb}) versus the number of observation points varyig from $N = 5000$ to $N = 1000000$ with $50$ iterations. The number of operations is drastically decreased.

Table 1 shows the system memory RAM usage needed to store the full sensibility matrix, the BTTB first row and the BCCB eigenvalues ($8$ times the BTTB first row). The quantities were computed for different numbers of data (N) with the same corresponding number of equivalent sources (N). Table 1 considers that each element of the matrix is a double-precision number, which requires 8 bytes of storage, except for the BCCB complex eigenvalues, which requires 16 bytes per element. Notice that $1,000.000$ observation points requires nearly $7.6$ Terabytes of memory RAM to store the whole sensibility matrix of the equivalent layer.

Using a PC with a Intel Core i7 4790@3.6GHz processor and 16 Gb of memory RAM, Figure \ref{fig:time_comparison}  compares the running time  of the  \citet{siqueira-etal2017} method with the one of our work, considering a constant number of iterations equal to 50. Clearly, the major advantage of our approach is its computational efficiency that allows a rapid calculation of the gravity forward modeling  with number of observations greater than $10,000$. Because of the RAM available in this system, we could not perform this comparison with more observations. Therefore, the number of observation is limited to $22,500$. Disregarding the limitation of 16 Gb of RAM, Figure \ref{fig:time_bccb} shows the running time of our method with 50 iterations and with the number of observations up to  25 millions. Our method requires $26:8$ seconds to run one million of observations, whereas \citet{siqueira-etal2017} method took $48:3$ seconds to run $22,500$ observations


\section{Synthetic tests}
In this section, we  investigate the effectiveness of using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product})  to solve, at each iteration, the forward modeling (the matrix-vector product $\mathbf{A} \hat{\mathbf{p}}^k$)  required in the fast equivalent layer proposed by \citet{siqueira-etal2017}.  We simulated three sources whose horizontal projections are shown in Figure \ref{fig:synthetic_data} as black lines.  These sources are two vertical prisms with density contrasts of $0.35 g/cm^3$ (upper-left prism) and $0.4 g/cm^3$ (upper-right prism) and a sphere with radius of 1,000 m with density contrast of $-0.5 g/cm^3$. Figure \ref{fig:synthetic_data}  shows the vertical component of gravity field generated by these sources contaminated with additive pseudorandom Gaussian noise with zero mean and standard deviation of $0.01486$ mGal.
 
The advantage of using the structures of BTTB and BCCB matrices to compute forward modeling in  the fast equivalent layer proposed by \citet{siqueira-etal2017} is grounded on the use of regular grids of data and equivalent sources. Hence, we created 10,000 observation points regularly spaced in a grid of $100 \times 100$ at $100$ m height. We also set a grid of equivalent point masses, each one directly beneath each observation points, located at $300$ m deep.  Figures \ref{fig:classic_fast_val}a and \ref{fig:bccb_fast_val}a  show the fitted gravity data obtained, respectively, by the fast equivalent layer using \citet{siqueira-etal2017} method and by our modified form of this method that computes the forward modeling using equation \ref{eq:BCCB_vector_product}. The corresponding residuals (Figures \ref{fig:classic_fast_val}b and \ref{fig:bccb_fast_val}b), defined as the difference between the observed (Figure  \ref{fig:synthetic_data}) and fitted gravity data (Figures \ref{fig:classic_fast_val}a and \ref{fig:bccb_fast_val}a), show means close to zero  and standard deviations of 0.0144 mGal.  Therefore, Figures \ref{fig:classic_fast_val} and \ref{fig:bccb_fast_val} show that \citet{siqueira-etal2017} method and our modified version of this method produced virtually the same results. This excellent agreement is confirmed in Figures \ref{fig:delta_comparison} and \ref{fig:delta_rho} which shows that there are virtually no differences, respectively,  in the fitted data presented in Figures \ref{fig:classic_fast_val}b and \ref{fig:bccb_fast_val}b and in the estimated mass distributions within the equivalent layers (not shown) yielded by both \citet{siqueira-etal2017} method and our modification of this method.  These results (\ref{fig:delta_comparison} and \ref{fig:delta_rho})  show that computing the matrix-vector product ($\mathbf{A} \hat{\mathbf{p}}^k$), required in the forward modeling, by means of embedding the BTTB matrix into a BCCB matrix (equation \ref{eq:BCCB_vector_product}) yields practically the same result as the one produced by computing this matrix-vector product  with a full matrix $\mathbf{A}$.

We perform two forms of processing the gravity data (Figure \ref{fig:synthetic_data}) through the equivalent layer technique: the upward (Figure \ref{fig:upward_comparison}) and the downward (Figure \ref{fig:downward_comparison}) continuations. The upward height is 300m and the downward  is at 50m.   Either in the upward continuation (Figure \ref{fig:upward_comparison}) or in the downward continuation (Figure \ref{fig:downward_comparison}), the continued gravity data using the fast equivalent layer proposed by \citet{siqueira-etal2017} (Figures \ref{fig:upward_comparison}a and \ref{fig:downward_comparison}a) are in close agreement with those produced by our modification of \citet{siqueira-etal2017} method (Figures \ref{fig:upward_comparison}b and \ref{fig:downward_comparison}b). The residuals (Figures \ref{fig:upward_comparison}c and \ref{fig:downward_comparison}c) quantify this agreement since their means and standard deviations are close to zero in both continued gravity data using both methods.  All the continued gravity data shown here (Figures \ref{fig:upward_comparison} and \ref{fig:downward_comparison}) agree with the true ones (not shown). The most striking feature of these upward or the downward continuations concerns the total computation time. The computation time spent by our method is approximately $1500$ times faster than \citet{siqueira-etal2017} method. 


\section{Real data test}
Test with real data are conducted with the gravity data from Caraj\'as, north of Brazil, were provided by the  Geological Survey of Brazil (CPRM). The real aerogravimetric data were collected in 113 flight lines along north–south direction with flight line spacing  of 3 km and tie lines along east–west direction at 12 km.

This airborne gravity survey was divided in two different areas, collected in different times, having samples spacing of 7.65 m and 15.21 m, totalizing  4,353,428 observation points. The height of the flight was fixed at 900 m. The gravity data (Figure \ref{fig:carajas_real_data}) were gridded into a regularly spaced dataset of $250,000$ observation points ($500 \times 500$) with a grid spacing of $716.9311$ km north-south and $781.7387$ km east-west.

To apply our modification of the fast equivalent layer method \citep{siqueira-etal2017}  that computes the forward modeling using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}), we set an equivalent layer at 300 m deep. Figure \ref{fig:carajas_gz_predito_val}a shows the fitted gravity data after with 50 iterations by applying our method approach. The residuals (Figure \ref{fig:carajas_gz_predito_val}b), defined as the difference between the observed (Figure \ref{fig:carajas_real_data}) and the predicted (Figure \ref{fig:carajas_gz_predito_val}a) data,  show an acceptable data fitting because they have a mean close to zero (0.000292 mGal) and a small standard deviation of 0.105 mGal which corresponds to approximately 0.1 \% of the amplitude of the gravity data.

These small residuals indicate that our method yielded an estimated mass distribution (not shown) that can be used in the data processing. We perform upward-continuation of the real gravity data (Figure \ref{fig:carajas_real_data}) at a constant height of 5000 m over the real data. The upward-continued gravity data (Figure \ref{fig:up2000_carajas_500x500}) seem a reasonable processing because of the attenuatinon of the short-wave lenghts. By using our approach, the processing of the 250,000 observations was extremely fast and took 0.216 seconds.


\section{Conclusions}
By exploring the properties related to Block-Toeplitz Toeplitz-block (BTTB) and Block-Circulant Circulant-Block (BCCB) matrices in the gravity data processing, we have proposed a new efficient approach for calculating the gravity-data forward modeling required in the iterative fast equivalent-layer technique grounded on excess mass constraint that does not demand  the solution of linear systems.  Its efficiency is grounded on the use of regular grids of observations and equivalent sources (point masses). Our algorithm greatly reduces the number of  flops necessary to estimate a 2D mass distribution within the equivalent layer that fits the observed gravity data. For example, when processing one million observations the number of flops is reduced in 104 times. Traditionally, such amount of data impractically requires 7.6 Terabytes of RAM memory to handle the full sensibility matrix. Rather, in our method, this matrix takes 61,035 Megabytes of RAM memory only.

Our method takes advantage of the symmetric BTTB system that arises when processing a harmonic function as the vertical component of gravity, that depends on the inverse
of distance between the observation and the point mass over the equivalent layer. Symmetric BTTB matrices can be stored by its only first row and can be embedded into a symmetric BCCB matrix, which in turn also only needs its first row.

Using the fast Fourier transform it is possible to calculate the eigenvalues of BCCB matrices which can
be used to compute a matrix-vector product (gravity-data forward modeling) in a very low computational cost. The time
needed to process medium-sized grids of observation, for example 22,500 points, is reduced in 102 times. We have successfully applied the proposed method to upward (or downward) synthetic gravity data. Testing on field data from the Caraj\'as Province, north of Brazil, confirms the potential of our approach in upward-continuing  gravity data with 250,000 observations in  about 0.2 seconds.  Our method allows, in future research, applying the equivalent layer technique for processing and interpreting massive data set such as collected in continental and global scales studies.

\newpage



\subsection*{Figures}
\renewcommand{\figdir}{Fig} % figure directory

Figure~\ref{fig:float}

\plot{float}{width=\textwidth}
{floating points to estimate the parameter vector using the fast equivalent layer with \citet{siqueira-etal2017} method (equation \ref{eq:float_classic}) and our approach (equation \ref{eq:float_bccb}) versus the numbers of observation points varyig from $N = 5000$ to $N = 1000000$ with $50$ iterations. The number of operations is drastically decreased.}
\newpage

Figure~\ref{fig:time_comparison}

\plot{time_comparison}{width=10cm}
{time necessary to run 50 iterations of the \citet{siqueira-etal2017} method and the one presented in this work. With the limitation of $16$ Gb of memory RAM in our system, we could test only up to $22500$ obervation points.}

Figure~\ref{fig:time_bccb}

\plot{time_bccb}{width=10cm}
{time necessary to run the equivalent layer technique with 50 iterations using only this new approach, where the RAM is not a limitation factor. We could run up to $25$ million observation points. In comparison, $1$ million observation points took $26.8$ seconds to run, where the maximun $22500$ observation points in figure \ref{fig:time_comparison}, with \citet{siqueira-etal2017} method, took $48.3$ seconds.}
\newpage

Figure~\ref{fig:synthetic_data}

\plot{synthetic_data}{width=13.5cm}
{model with two polygonal prisms, with density contrast of $0.35$ (upper-left body) and $0.4 g/cm^3$ (upper-right body), and a sphere with radius of $1000 m$ with density contrast of $-0.5 g/cm^3$. The vertical component of gravity generated by this bodies were calculated and are shown together with their horizontal projections. A gaussian noise was added to the data with mean of zero and maximum value of $0.5\%$ of the maximum of the original data. As previous said only in regular grids the BTTB matrix structures appears. We created $10000$ observation points regularly spaced in a grid of $100 \times 100$, with a uniform $100 m$ of height for all the observations.}
\newpage

Figure~\ref{fig:classic_fast_val}

\plot{classic_fast_val}{width=8cm}
{(a) Fitted gravity data produced by the fast equivalent layer proposed by \citet{siqueira-etal2017}. (b) Gravity residuals, defined as the difference between the observed data in Figure \ref{fig:synthetic_data} and the predicted data in (a), with their mean of $8.264e-7$ and standard deviation of $0.0144$ mGal.}
\newpage

Figure~\ref{fig:bccb_fast_val}

\plot{bccb_fast_val}{width=8cm}
{(a) Fitted gravity data produced by our modification of the fast equivalent layer proposed by \citet{siqueira-etal2017}. (b) Gravity residuals, defined as the difference between the observed data in Figure 4 and the predicted data in (a), with their mean of $8.264e-7$ and standard deviation of $0.0144$ mGal.}
\newpage

Figure~\ref{fig:delta_comparison}

\plot{delta_comparison}{width=13.5cm}
{Difference between the fitted gravity data produced by \citet{siqueira-etal2017} method (Figure \ref{fig:classic_fast_val}a) and by our modified form of this method that computes the forward modeling using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}).}
\newpage

Figure~\ref{fig:delta_rho}

\plot{delta_rho}{width=13.5cm}
{Difference between the estimated mass distribution within the equivalent layer produced by \citet{siqueira-etal2017} method (Figure \ref{fig:classic_fast_val}a) and by our modified form of this method that computes the forward modeling using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}).}
\newpage

Figure~\ref{fig:upward_comparison}

\plot{upward_comparison}{width=5cm}
{The upward-continued gravity data using: (a) the fast equivalent layer proposed by \citet{siqueira-etal2017} and (b) our modified form of \citet{siqueira-etal2017} method by using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}) to calculate the forward modeling.  (c) Residuals, defined as the difference between a and b with their mean of $-5.938e-18$ and standard deviation of $8.701e-18$.  The total computation times in the \citet{siqueira-etal2017} method and in our approach are $7.62026$ and $0.00834$ seconds, respectively.}
\newpage

Figure~\ref{fig:downward_comparison}

\plot{downward_comparison}{width=5cm}
{The downward-continued gravity data using: (a) the fast equivalent layer proposed by \citet{siqueira-etal2017} and (b) our modified form of \citet{siqueira-etal2017} method by using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}) to calculate the forward modeling.  (c) Residuals, defined as the difference between a and b with their mean of $5.914e-18$ and standard deviation of $9.014e-18$.  The total computation times in the \citet{siqueira-etal2017} method and in our approach are $7.59654$ and $0.00547$ seconds, respectively.}
\newpage

Figure~\ref{fig:carajas_real_data}

\plot{carajas_real_data}{width=13.5cm}
{Caraj\'as Province, Brazil. Gravity data on a regular grid of $500 \times 500$ points, totaling $250,000$ observations. The inset shows the study area (blue rectangle) which covers the southeast part of the state of Par\'a, north of Brazil.}
\newpage

Figure~\ref{fig:carajas_gz_predito_val}

\plot{carajas_gz_predito_val}{width=8cm}
{Caraj\'as Province, Brazil. (a) Predicted gravity data produced by our modification of the fast equivalent layer method \citep{siqueira-etal2017}  that computes the forward modeling using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}). (b) Gravity residuals, defined as the difference between the observed data in Figure \ref{fig:carajas_real_data} and the predicted data in a, with their mean of 0.000292 mGal and standard deviation of $0.105$ mGal.}
\newpage

Figure~\ref{fig:up2000_carajas_500x500}

\plot{up2000_carajas_500x500}{width=13.5cm}
{Caraj\'as Province, Brazil. The upward-continued gravity data using our modification of the fast equivalent layer method \citep{siqueira-etal2017} that computes the forward modeling using the properties of BTTB and BCCB matrices (equation \ref{eq:BCCB_vector_product}). The total computation time is 0.216 seconds for processing of the $250,000$ observations.}
\newpage

%\subsubsection{Multiplot} 
%Sometimes it is convenient to put two or more figures from different
%files in an array (see Figure~\ref{fig:exph,exgr}). Individual plots
%are Figures~\ref{fig:exph} and~\ref{fig:exgr}.
%
%\multiplot{2}{exph,exgr}{width=0.4\textwidth}
%{This figure is specified in the document by \newline \texttt{
%    $\backslash$multiplot\{2\}\{exph,exgr\}\{width=0.4$\backslash$textwidth\}\{This caption.\}}.
%}
%
%The first argument of the \texttt{multiplot} command specifies the
%number of plots per row.

\subsection{Tables}

\begin{table}[h]
	\begin{center}
		\begin{tabular}{|l|c|c|c|}
			\hline
			\textbf{$N \times N$} & \textbf{Full RAM (Mb)} & \textbf{BTTB RAM (Mb)}  & \textbf{BCCB RAM (Mb)}\\
			\hline 
			$100 \times 100$ & 0.0763 & 0.0000763 & 0.0006104\\
			\hline
			$400 \times 400$ & 1.22 & 0.0031 & 0.0248\\
			\hline
			$2500 \times 2500$ & 48 & 0.0191 & 0.1528\\
			\hline
			$10000 \times 10000$ & 763 & 0.00763 & 0.6104\\
			\hline
			$40000 \times 40000$ & 12207 & 0.305 & 2.4416 \\
			\hline
			$250000 \times 250000$ & 476837 & 1.907 & 15.3 \\
			\hline
			$500000 \times 500000$ & 1907349 & 3.815 & 30.518 \\
			\hline
			$1000000 \times 1000000$ & 7629395 & 7.629 & 61.035 \\
			\hline
		\end{tabular}
		\caption{Comparison between the system memory RAM usage needed to store the full matrix, the BTTB first row and the BCCB eigenvalues (eight times the BTTB). The quantities were computed for different numbers of data (N) with the same corresponding number of equivalent sources (N). This table considers that each element of the matrix is a double-precision number, which requires 8 bytes of storage, except for the BCCB complex eigenvalues, which requires 16 bytes per element.}
	\end{center}
\end{table} 

%The discussion is summarized in Table~\ref{tbl:example}.
%
%\tabl{example}{This table is specified in the document by \texttt{
%    $\backslash$tabl\{example\}\{This caption.\}\{\ldots\}}.
%}{
%  \begin{center}
%    \begin{tabular}{|c|c|c|}
%      \hline
%      \multicolumn{3}{|c|}{Table Example} \\
%      \hline
%      migration\rule[-2ex]{0ex}{5ex} & 
%      $\omega \rightarrow k_z$ & 
%      $k_y^2+k-z^2\cos^2 \psi=4\omega^2/v^2$ \\
%      \hline
%      \parbox{1in}{zero-offset\\diffraction}\rule[-4ex]{0ex}{8ex} &
%      $k_z\rightarrow\omega_0$ &
%      $k_y^2+k_z^2=4\omega_0^2/v^2$ \\
%      \hline
%      DMO+NMO\rule[-2ex]{0in}{5ex} & $\omega\rightarrow\omega_0$ & 
%      $\frac{1}{4}
%      v^2k_y^2\sin^2\psi+\omega_0^2\cos^2\psi=\omega^2$ \\
%      \hline
%      radial DMO\rule[-2ex]{0in}{5ex} & $\omega\rightarrow\omega_s$ &
%      $\frac{1}{4}v^2k_y^2\sin^2\psi+\omega_s^2=\omega^2$\\
%      \hline
%      radial NMO\rule[-2ex]{0in}{5ex} & $\omega_s\rightarrow\omega_0$ &
%      $\omega_0\cos\psi=\omega_s$\\
%      \hline
%    \end{tabular}
%  \end{center}
%}

\section{ACKNOWLEDGMENTS}

This study was financed by the brazilian agencies CAPES (in the form of a scholarship), FAPERJ (grant n.$^{\circ}$ E-26 202.729/2018) and CNPq (grant n.$^{\circ}$ 308945/2017-4).

%\append{Appendix example}

%\append[equations]{Another appendix}

%\sideplot{errgrp}{width=0.8\textwidth}
%{This figure is specified in the document by \texttt{
%    $\backslash$sideplot\{errgrp\}\{width=0.8$\backslash$text\-width\}\{This caption.\}}.


%\append{The source of this document}

%\verbatiminput{geophysics_example.ltx}

%\append{The source of the bibliography}

%\verbatiminput{example.bib}

\newpage

\bibliographystyle{seg}  % style file is seg.bst
\bibliography{references}

\end{document}
